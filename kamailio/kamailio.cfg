#!KAMAILIO
####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
#!define FLB_RTPWS 8

#!define FLT_FROMINTERNAL 9

#!define FLD_RTPPROXY 10

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

# UDP
listen=udp:EXTERNAL_IF_SIP:MY_SIP_PORT advertise EXTERNAL_DOMAIN:MY_SIP_PORT

# HTTP 
listen=tcp:EXTERNAL_IF_HTTP:MY_HTTP_PORT

# TLS
enable_tls=yes
listen=tls:EXTERNAL_IF_SIP:MY_SIPS_PORT advertise EXTERNAL_DOMAIN:MY_SIPS_PORT
tcp_connection_lifetime=3605
tcp_max_connections=2048
tcp_accept_no_cl=yes

# WebSocket
listen=tcp:EXTERNAL_IF_SIP:MY_WS_PORT advertise EXTERNAL_DOMAIN:MY_WS_PORT
listen=tls:EXTERNAL_IF_SIP:MY_WSS_PORT advertise EXTERNAL_DOMAIN:MY_WSS_PORT

####### Custom Parameters #########

mhomed=0

####### Internal DNS cache parameters #########

use_dns_cache=on
dns_retr_time=1
dns_retr_no=3
dns_srv_loadbalancing=on
dns_srv_loadbalancing=on
dns_naptr_ignore_rfc=yes
dns_tls_pref=50			# First priority: TLS
dns_tcp_pref=30			# Second priority: TCP
dns_udp_pref=10			# Third priority: UDP

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "uac.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "usrloc.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "registrar.so"
loadmodule "path.so"
loadmodule "xhttp.so"
loadmodule "dialog.so"
loadmodule "tls.so"
loadmodule "websocket.so"

# ----------------- setting module-specific parameters ---------------
modparam("tls", "config", "/etc/kamailio/tls.cfg")

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 2000)
modparam("tm", "retr_timer1", 250)
modparam("tm", "retr_timer2", 500)
# default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "reparse_on_dns_failover", 0)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "tsuspenddata=>size=8;autoexpire=5;")
modparam("htable", "htable", "usertoserver=>size=8;autoexpire=600;updateexpire=0")

modparam("uac","restore_mode","none")

modparam("http_client", "connection_timeout", 1)
modparam("http_client", "keep_connections", 1)

modparam("rtpengine", "rtpengine_sock", "udp:localhost:12221")

modparam("nathelper", "natping_interval", 10)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@EXTERNAL_DOMAIN")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")


modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

modparam("usrloc", "db_mode", 0)
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)

# modparam("xhttp", "url_match", "^/user/")

modparam("dialog", "default_timeout", 10800) # 3h
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 0)
modparam("dialog", "send_bye", 1)

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

    route(CHECK_DIAL_OUT);

    # NAT detection. Moved here to route initial answers correctly
    route(NATDETECT);

    # per request initial checks
    route(INITIAL_CHECK);

    route(WITHINDLG);

    route(RETRANSMISSIONS);

    route(OPTIONS);

    route(CANCEL);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    route(REGISTRAR);

    if ($rU==$null && !is_method("REGISTER")) {
        # request with no Username in RURI and not REGISTER's
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    route(DIAL_OUT);

    route(GET_SERVERS);
}

route[CHECK_DIAL_OUT] {
    if ($hdr(X-Trusted-Source) == "yes") {
        setflag(FLT_FROMINTERNAL);
    }
    return;
}


route[RETRANSMISSIONS] {
    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
}

route[CANCEL] {
    if (!is_method("CANCEL")) {
        return;
    }

    if (t_check_trans()) {
        route(RELAY);
    }
    exit;
}

route[CHECK_DESTINATION] {

    t_on_failure("CHECK_FAILED");

    if (!t_suspend()) {
        send_reply("500", "Suspend failed");
        exit;
    } else {
        xlog("[$TF/$rm/$ci][CHECK_DESTINATION] Suspending $rm at $T(id_index)/$T(id_label)...\n");
    }

    $avp(generated_call_id) = $(mb{s.md5});

    $uac_req(method) = "OPTIONS";
    $uac_req(ruri) = $avp(redirect_server);
    $uac_req(furi) = "sip:EXTERNAL_DOMAIN:MY_SIP_PORT";
    $uac_req(turi) = $avp(redirect_server);
    $uac_req(callid) = $avp(generated_call_id);
    $uac_req(evroute) = 1;
    $uac_req(evparam) = $avp(generated_call_id);
    xlog("[CHECK_DESTINATION] Cheking $avp(redirect_server)...\n");

    $sht(tsuspenddata=>$avp(generated_call_id))="index=" + $T(id_index) + ";label=" + $T(id_label);
    if (!uac_req_send()) {
        xlog("[$TF/$rm/$ci][CHECK_DESTINATION] Cannot send to $avp(redirect_server), resuming transaction\n");
        t_continue("$T(id_index)", "$T(id_label)", "SEND_CHECK_FAILED");
    }
    exit;
}

# Wrapper for redirecting/proxying requests
route[PROXY_FURTHER] {

    $sht(usertoserver=>$fU) = "server=" + $avp(redirect_server) + ";mode=" + $avp(km_op_mode);

    if ($avp(km_op_mode) == 'redirect') {
        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Redirecting $rm to $avp(redirect_server)...\n");
        append_branch("$avp(redirect_server)");
        send_reply("302", "Redirect");
        exit;
    }

    if ($avp(km_op_mode) == 'disabled') {
        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Replying 404 to $rm as it's disabled\n");
        send_reply("404", "User not found");
        exit;
    }

    if ($avp(km_op_mode) == 'sip') {

        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Relaying $rm to $avp(redirect_server) with sip only mode\n");
        append_hf("X-Orig-Source: $su\n", "Call-ID");
        $du = $avp(redirect_server);
        
        route(RELAY);
    }

    if ($avp(km_op_mode) == 'rtp') {

        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Relaying $rm to $avp(redirect_server) with sip+rtp mode\n");
        append_hf("X-Orig-Source: $su\n", "Call-ID");
        $du = $avp(redirect_server);

        if (is_method("INVITE") && !has_totag()) {
            dlg_manage();
            dlg_setflag(FLD_RTPPROXY);
        }

        route(RELAY);
    }

    xlog("[$TF/$rm/$ci][PROXY_FURTHER] Replying 603 to $rm as mode $avp(km_op_mode) is not known\n");
    send_reply("603", "Decline");
    exit;
}


# Wrapper for relaying requests
route[RELAY] {

    # At this point all checks are passed
    t_on_branch("MANAGE_BRANCH");
    t_on_reply("MANAGE_REPLY");
    t_on_failure("MANAGE_FAILURE");

    if (!t_relay()) {
        send_reply("500", "Cannot relay to $du/$ru");
    }
    exit;
}


# Per SIP request initial checks
route[INITIAL_CHECK] {

    # First - check SIP message is valid.
    if(!sanity_check("17895", "7")) {
        xlog("L_ALERT", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # flood detection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent|MizuPhone|pplsip|tgzwer|fgfdhgfxjfhyjhkj|axzxccbvcnbxcbzxvssmnnsbscbs|VoIP SIP") {
        # Reply to sip scanners helps according to Daniel-Konstantin Merida
        send_reply("200", "OK");
        xlog("L_INFO","friendly-scanner blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }

    if(is_method("REGISTER|INVITE") && !has_totag()) {

         if ($ua == $null || $ua == '') {
            # Blank UA's are suspicious....
            send_reply("200", "OK");
            xlog("L_INFO","Without UA blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
         }

        #if (!is_numeric($fU)) {
        #    # Allow only numeric From
        #    send_reply("200", "OK");
        #    xlog("L_INFO","Non-numeric From blocking $rm from $fu (IP:$si:$sp)\n");
        #    $sht(ipban=>$si) = 1;
        #    exit;
        #}
    }

    #if (!is_numeric($fU))

    if (!mf_process_maxfwd_header("10")) {
        send_reply("483","Too Many Hops");
        xlog("L_INFO","maxHop blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }

    # For Blocking request coming on direct IPs
    #if($fd =~ "^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})$" || $td =~ "^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})$") {
    #    #send_reply("200", "OK");
    #    xlog("L_INFO","Using IP instead of Domain From blocking $rm from $fu (IP:$si:$sp)r\n");
    #    #$sht(ipban=>$si) = 1;
    #    exit;
    #}

}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }

    if (is_method("BYE")) {
        rtpengine_delete();
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        exit;
    }
    if (is_method("ACK") ) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    send_reply("404","Not here");
    exit;
}


# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset() || $du == "") {
        if (!handle_ruri_alias()) {
            xlog("[$TF/$rm/$ci][DLGURI] Bad alias <$ru>\n");
            sl_send_reply("400", "Bad Request");
            exit;
        }
    }
    return;
}

route[OPTIONS] {

    if (!is_method("OPTIONS")) {
        return;
    }

    if(uri==myself && $rU==$null) {
        xlog("[$TF/$rm/$ci][OPTIONS] Options for myself. Replying...\n");
        send_reply("200","Keepalive");
        exit;
    }

    if (handle_ruri_alias()) {
        xlog("[$TF/$rm/$ci][OPTIONS] Alias found in request!\n");
        route(RELAY);
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
}

# Presence server processing
route[PRESENCE] {

    if(!is_method("PUBLISH|SUBSCRIBE")) {
        return;
    }

    if (!isflagset(FLT_FROMINTERNAL)) {
        route(GET_SERVERS);
    } else {
        handle_ruri_alias();
    }

    route(RELAY);
}

route[GET_SERVERS] {

    if ($sht(usertoserver=>$fU) != $null) {

        $avp(redirect_server) = $(sht(usertoserver=>$fU){param.value,server});
        $avp(km_op_mode) = $(sht(usertoserver=>$fU){param.value,mode});

        xlog("[$TF/$rm/$ci][GET_SERVERS] Got answer from cache $avp(redirect_server) with $avp(km_op_mode) mode\n");
        route(PROXY_FURTHER);
    }

    $var(http_request_url) = "API_SERVER_ADDRESS/" + $fU;


    $var(http_request_result) = http_client_query("$var(http_request_url)", 
                                                "", 
                                                "Accept: application/json", 
                                                "$avp(http_reply_body)");

    if ($var(http_request_result) != 200) {
        xlog("[$TF/$rm/$ci][GET_SERVERS] http_request_result is not 200 ($var(http_request_result))\n");

        route(USE_DEFAULT_ACTION);
    }

    jansson_array_size("", "$avp(http_reply_body)", "$avp(http_reply_size)");

    xlog("[$TF/$rm/$ci][GET_SERVERS] Size: $avp(http_reply_size) -> $avp(http_reply_body)\n");

    $avp(current_reply_index) = 0;

    route(MANAGE_HTTP_ANSWER);
}

route[MANAGE_HTTP_ANSWER] {
    if ($avp(http_reply_size) > $avp(current_reply_index)) {

        if (!jansson_get("[$avp(current_reply_index)].server.sip_server", "$avp(http_reply_body)", "$var(current_sip_server)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get sip_server from JSON $avp(http_reply_body)\n");
            route(USE_DEFAULT_ACTION);
        }

        if (!jansson_get("[$avp(current_reply_index)].server.port", "$avp(http_reply_body)", "$var(current_sip_port)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get sip_port from JSON $avp(http_reply_body), using MY_SIP_PORT\n");
            $var(current_sip_port) = 'MY_SIP_PORT';
        }

        if (!jansson_get("[$avp(current_reply_index)].km_op_mode", "$avp(http_reply_body)", "$avp(km_op_mode)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get km_op_mode from JSON $avp(http_reply_body), using DEFAULT_KMOPMODE\n");
            $avp(km_op_mode) = "DEFAULT_KMOPMODE";
        }

        $avp(redirect_server) = "sip:" + $var(current_sip_server) + ":" + $var(current_sip_port);

        xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] About to check $avp(redirect_server)\n");

        $avp(current_reply_index) = $avp(current_reply_index) + 1;

        route(CHECK_DESTINATION);

    } else {

        xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] All servers seems failed, using default one..\n");

        route(USE_DEFAULT_ACTION);
    }
}

route[USE_DEFAULT_ACTION] {

    xlog("[$TF/$rm/$ci][USE_DEFAULT_ACTION] All servers seems failed, using default one..\n");

    $avp(redirect_server) = "DEFAULT_SERVER";
    $avp(km_op_mode) = "DEFAULT_KMOPMODE";

    route(PROXY_FURTHER);
    exit;
}

route[SEND_CHECK_FAILED] {

    xlog("[$TF/$rm/$ci][SEND_CHECK_FAILED] Check failed, trying next one..\n");

    $sht(tsuspenddata=>$avp(generated_call_id)) = $null;

    route(MANAGE_HTTP_ANSWER);
}


# RTPEngine control and signaling updates for NAT traversal
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
            if (check_route_param("rtp=ws")) {
				setbflag(FLB_RTPWS);
			}
        }
    }

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB) || isbflagset(FLB_RTPWS))) {
        return;
    }

    $xavp(r=>$T_branch_idx) = "replace-origin replace-session-connection";

    if (!nat_uac_test("8")) {
		$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " trust-address";
	}

    if (is_request()) {
		if (!has_totag()) {
			if (!t_is_failure_route()) {
				$avp(extra_id) = @via[1].branch + $T_branch_idx;
				$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " via-branch=extra";
			}
		}
	}

	if (is_reply()) {
		$avp(extra_id) = @via[2].branch + $T_branch_idx;
		$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " via-branch=extra";
	}

	if (isbflagset(FLB_RTPWS)) {
		if ($proto =~ "ws") { # web --> SIP
			$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " rtcp-mux-demux DTLS=off SDES-off ICE=remove RTP/AVP";
		} else { # SIP --> web
			$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force RTP/SAVPF";
		}
	} else {
		if ($proto =~ "ws") { # web --> web
			$xavp(r=>$T_branch_idx) = $xavp(r=>$T_branch_idx) + " generate-mid DTLS=passive SDES-off ICE=force";
		}
	}

	xlog("L_INFO", "NATMANAGE branch_id:$T_branch_idx ruri: $ru, method:$rm, status:$rs, extra_id: $avp(extra_id), rtpengine_manage: $xavp(r=>$T_branch_idx)\n");
    route(RTPENGINE);

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                if (isbflagset(FLB_NATB)) {
					add_rr_param(";nat=yes");
				}
                if (isbflagset(FLB_RTPWS)) {
					add_rr_param(";rtp=ws");
				}
            }
        }
    }
    if (is_reply()) {
        set_contact_alias();
    }
}

route[RTPENGINE] {

    if(!has_body("application/sdp")) {
        return;
    }

    if ($avp(km_op_mode) == 'rtp' || dlg_isflagset(FLD_RTPPROXY)) {
        rtpengine_manage($xavp(r=>$T_branch_idx));
    }
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) {
        return;
    }

    if(isflagset(FLT_NATS)) {

        setbflag(FLB_NATB);
        # do SIP NAT pinging
        setbflag(FLB_NATSIPPING);
    }
    if ($au != $null) {         # Save only with authorized headers. It's actully for pings only
        save("location", "2");
    }

    set_contact_alias();
    add_path_received();
}

route[DIAL_OUT] {
    if (!isflagset(FLT_FROMINTERNAL)) {
        return;
    }

    handle_ruri_alias();
    route(RELAY);
}

route[BRIDGING] {
	if (!has_totag()) {
		if ($proto =~ "ws" && !($ru =~ "transport=ws")) { # Coming from WS, NOT to WS
			setbflag(FLB_RTPWS); # Need bridging
		} else if (!($proto =~ "ws") && $ru =~ "transport=ws") { # Coming from NOT WS, going to WS
			setbflag(FLB_RTPWS); # Need bridging
		}
	}
}

event_route[uac:reply] {

    $var(t_data) = $null;

    xlog("[$TF/$rm/$ci][UAC_REPLY] Received reply code is: $uac_req(evcode)/$uac_req(evparam)\n");

    $var(t_data) = $sht(tsuspenddata=>$uac_req(evparam));

    if ($var(t_data) == $null || $var(t_data) == "") {
        xlog("[$TF/$rm/$ci][UAC_REPLY] Data expired?\n");
        drop;
    }

    $var(t_index) = $(var(t_data){param.value,index}{s.int});
    $var(t_label) = $(var(t_data){param.value,label}{s.int});

    if ($uac_req(evcode) != 408) {
        t_continue("$var(t_index)", "$var(t_label)", "PROXY_FURTHER");
    } else {
        t_continue("$var(t_index)", "$var(t_label)", "SEND_CHECK_FAILED");
    }
}

event_route[xhttp:request] {

    xlog("[$TF/$rm/$ci][xhttp:request] Request is $hu\n");

    set_reply_close();
	set_reply_no_connect();

    if ($(hu{s.select,1,/}) == 'user' && $Rp == MY_HTTP_PORT) {

        switch ($(hu{s.select,2,/})) {
            case "list":
                $var(user_name) = $(hu{s.select,3,/});
                $var(user_data) = $sht(usertoserver=>$var(user_name));

                $var(redirect_server) = $(var(user_data){param.value,server});
                $var(km_op_mode) = $(var(user_data){param.value,mode});

                xhttp_reply("200", "OK", "application/json", 
                    "{\"username\":\"$var(user_name)\",\"server\":\"$var(redirect_server)\",\"km_op_mode\":\"$var(km_op_mode)\"}");
                break;
        
            case "delete":
                $var(user_name) = $(hu{s.select,3,/});

                if ($var(user_name) == 'all') {
                    sht_reset("usertoserver");
                } else {
                    $sht(usertoserver=>$var(user_name)) = $null;
                }

                xhttp_reply("200", "OK", "application/json", "{\"200\", \"Deleted\"}");
                break;

            default:
                xhttp_reply("200", "OK", "application/json", "{\"200\", \"OK\"}");
        }
    }


	if ($Rp != MY_WS_PORT
		&& $Rp != MY_WSS_PORT
	) {
		xlog("L_WARN", "HTTP request received on $Rp\n");
		xhttp_reply("403", "Forbidden", "", "");
		exit;
	}

    if ($hdr(Upgrade) =~ "websocket"
		&& $hdr(Connection) =~ "Upgrade"
		&& $rm =~ "GET"
	) {

		# Validate Host - make sure the client is using the correct
		# alias for WebSockets
		if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}

		# Optional... perform HTTP authentication

		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake()) {
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}

	xhttp_reply("404", "Not Found", "", "");

}

failure_route[CHECK_FAILED] {
    xlog("[$TF/$rm/$ci][CHECK_FAILED] for $rm/$ci\n");

    route(SEND_CHECK_FAILED);
}

# Default reply/faulure routes

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("[$TF/$rm/$ci][MANAGE_BRANCH] for $rm/$ci\n");

    if ($avp(km_op_mode) == 'rtp') {
        t_on_branch_failure("rtpengine");
    }

    route(BRIDGING);
    route(NATMANAGE);
}

onreply_route {
	if ((($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT)
		&& !(proto == WS || proto == WSS))) {
		drop;
	}

	if (nat_uac_test(64)) {
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
		add_contact_alias();
	}
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("[$TF/$rm/$ci][MANAGE_REPLY] for $rm/$ci\n");

    if(status=~"[12][0-9][0-9]") {
        route(NATDETECT);
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    xlog("[$TF/$rm/$ci][MANAGE_FAILURE] for $rm/$ci\n");
}


event_route[tm:branch-failure:rtpengine] {
	xlog("L_INFO", "BRANCH FAILED: $sel(via[1].branch) + $T_branch_idx");

	$avp(extra_id) = @via[1].branch + $T_branch_idx;
	rtpengine_delete("via-branch=extra");
}