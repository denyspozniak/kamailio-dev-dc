#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.2 - default configuration script
#     - web: https://www.kamailio.org
#     - git: https://github.com/kamailio/kamailio
#
# Direct your questions about this file to: <sr-users@lists.kamailio.org>
#
# Refer to the Core CookBook at https://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Note: the comments can be:
#     - lines starting with #, but not the pre-processor directives,
#       which start with #!, like #!define, #!ifdef, #!endif, #!else, #!trydef,
#       #!subst, #!substdef, ...
#     - lines starting with //
#     - blocks enclosed in between /* */
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     - define WITH_DEBUG
#
# *** To enable mysql:
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database

#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########


#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
 
# First provide internal interfaces to correct dispatcher pings

listen=udp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR
listen=tcp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR

mhomed=0

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

#!ifdef WITH_TLS
enable_tls=yes

/* upper limit for TLS connections */
tls_max_connections=2048
#!endif

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "uac.so"
loadmodule "http_client.so"
loadmodule "jansson.so"

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 2000)
modparam("tm", "retr_timer1", 250)
modparam("tm", "retr_timer2", 500)
# default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "reparse_on_dns_failover", 0)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "tsuspenddata=>size=8;autoexpire=20;")
modparam("htable", "htable", "usertoserver=>size=8;autoexpire=600;")

modparam("uac","restore_mode","none")

modparam("http_client", "connection_timeout", 1)
modparam("http_client", "keep_connections", 1)

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
    # NAT detection. Moved here to route initial answers correctly
    route(NATDETECT);

    # per request initial checks
    route(INITIAL_CHECK);

    route(RETRANSMISSIONS);

    route(OPTIONS);

    route(GET_SERVERS);
}


route[RETRANSMISSIONS] {
    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
}

route[CHECK_DESTINATION] {

    t_on_failure("CHECK_FAILED");

    if (!t_suspend()) {
        send_reply("500", "Suspend failed");
        exit;
    } else {
        xlog("[$TF][CHECK_DESTINATION] Suspending $rm at $T(id_index)/$T(id_label)...\n");
    }

    $avp(generated_call_id) = $(mb{s.md5});

    $uac_req(method) = "OPTIONS";
    $uac_req(ruri) = $avp(redirect_server);
    $uac_req(furi) = "sip:EXTERNAL_ADDR";
    $uac_req(turi) = $avp(redirect_server);
    $uac_req(callid) = $avp(generated_call_id);
    $uac_req(evroute) = 1;
    $uac_req(evparam) = $avp(generated_call_id);
    xlog("[CHECK_DESTINATION] Cheking $avp(redirect_server)...\n");

    $sht(tsuspenddata=>$avp(generated_call_id))="index=" + $T(id_index) + ";label=" + $T(id_label);
    if (!uac_req_send()) {
        xlog("[$TF][CHECK_DESTINATION] Cannot send to $avp(redirect_server), resuming transaction\n");
        t_continue("$T(id_index)", "$T(id_label)", "SEND_CHECK_FAILED");
    }
    exit;
}

# Wrapper for redirecting requests
route[REDIRECT] {

    $sht(usertoserver=>$fU) = $avp(redirect_server);

    xlog("[$TF][REDIRECT] Redirecting $rm to $avp(redirect_server)...\n");

    append_branch("$avp(redirect_server)");
    send_reply("302", "Redirect");
    exit;
}


# Per SIP request initial checks
route[INITIAL_CHECK] {

    # First - check SIP message is valid.
    if(!sanity_check("17895", "7")) {
        xlog("L_ALERT", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # flood detection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        # Reply to sip scanners helps according to Daniel-Konstantin Merida
        send_reply("200", "OK");
        xlog("L_INFO","friendly-scanner blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        #sl_send_reply("483","Too Many Hops");
        xlog("L_INFO","maxHop blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
}

route[OPTIONS] {

    if (!is_method("OPTIONS")) {
        return;
    }

    if(uri==myself && $rU==$null) {
        send_reply("200","Keepalive");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
}

route[GET_SERVERS] {
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/0001'
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/700000480001'
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/700000460002'

    if ($sht(usertoserver=>$fU) != $null) {
        $avp(redirect_server) = $sht(usertoserver=>$fU);
        xlog("[$TF][GET_SERVERS] Got answer from cache $avp(redirect_server)\n");
        route(REDIRECT);
    }

    $var(http_request_url) = "API_SERVER_ADDRESS/" + $fU;


    $var(http_request_result) = http_client_query("$var(http_request_url)", 
                                                "", 
                                                "Accept: application/json", 
                                                "$avp(http_reply_body)");

    if ($var(http_request_result) != 200) {
        $avp(redirect_server) = "DEFAULT_SERVER";
        route(REDIRECT);
    }

    jansson_array_size("", "$avp(http_reply_body)", "$avp(http_reply_size)");

    xlog("[$TF][GET_SERVERS] Size: $avp(http_reply_size) -> $avp(http_reply_body)\n");

    $avp(current_reply_index) = 0;

    route(MANAGE_HTTP_ANSWER);
}

route[MANAGE_HTTP_ANSWER] {
    if ($avp(http_reply_size) > $avp(current_reply_index)) {

        jansson_get("[$avp(current_reply_index)].sip_server", "$avp(http_reply_body)", "$var(current_sip_server)");
        jansson_get("[$avp(current_reply_index)].port", "$avp(http_reply_body)", "$var(current_sip_port)");
        $avp(redirect_server) = "sip:" + $var(current_sip_server) + ":" + $var(current_sip_port);

        xlog("[$TF][MANAGE_HTTP_ANSWER] About to check $avp(redirect_server)\n");

        $avp(current_reply_index) = $avp(current_reply_index) + 1;

        route(CHECK_DESTINATION);

    } else {
        
        $avp(redirect_server) = "DEFAULT_SERVER";
        xlog("[$TF][MANAGE_HTTP_ANSWER] All servers seems failed, using default one...$avp(redirect_server)\n");

        route(REDIRECT);
    }
}

route[SEND_CHECK_FAILED] {

    xlog("[$TF][SEND_CHECK_FAILED] Check failed, trying next one..\n");

    $sht(tsuspenddata=>$avp(generated_call_id)) = $null;

    route(MANAGE_HTTP_ANSWER);
}

event_route[uac:reply] {

    xlog("[$TF][UAC_REPLY] Received reply code is: $uac_req(evcode)/$uac_req(evparam)\n");

    $var(t_data) = $sht(tsuspenddata=>$uac_req(evparam));

    if ($var(t_data) == $null) {
        xlog("[$TF][UAC_REPLY] Data expired?\n");
        drop;
    }

    $var(t_index) = $(var(t_data){param.value,index}{s.int});
    $var(t_label) = $(var(t_data){param.value,label}{s.int});

    if ($uac_req(evcode) != 408) {
        t_continue("$var(t_index)", "$var(t_label)", "REDIRECT");
    } else {
        t_continue("$var(t_index)", "$var(t_label)", "CHECK_FAILED");
    }
}

failure_route[CHECK_FAILED] {

    xlog("[$TF][CHECK_FAILED] Check failed, trying next one..\n");

    $sht(tsuspenddata=>$avp(generated_call_id)) = $null;

    route(MANAGE_HTTP_ANSWER);
}