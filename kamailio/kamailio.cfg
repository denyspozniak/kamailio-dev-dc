#!KAMAILIO
####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

listen=udp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR
listen=tcp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR

mhomed=0

tcp_connection_lifetime=3605
tcp_max_connections=2048

####### Custom Parameters #########

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "uac.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "rtpengine.so"

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 2000)
modparam("tm", "retr_timer1", 250)
modparam("tm", "retr_timer2", 500)
# default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "reparse_on_dns_failover", 0)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "tsuspenddata=>size=8;autoexpire=3;")
modparam("htable", "htable", "usertoserver=>size=8;autoexpire=600;")

modparam("uac","restore_mode","none")

modparam("http_client", "connection_timeout", 1)
modparam("http_client", "keep_connections", 1)

modparam("rtpengine", "rtpengine_sock", "udp:localhost:12221")

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
    # NAT detection. Moved here to route initial answers correctly
    route(NATDETECT);

    # per request initial checks
    route(INITIAL_CHECK);

    route(WITHINDLG);

    route(RETRANSMISSIONS);

    route(OPTIONS);

    route(GET_SERVERS);
}


route[RETRANSMISSIONS] {
    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
}

route[CHECK_DESTINATION] {

    t_on_failure("CHECK_FAILED");

    if (!t_suspend()) {
        send_reply("500", "Suspend failed");
        exit;
    } else {
        xlog("[$TF][CHECK_DESTINATION] Suspending $rm at $T(id_index)/$T(id_label)...\n");
    }

    $avp(generated_call_id) = $(mb{s.md5});

    $uac_req(method) = "OPTIONS";
    $uac_req(ruri) = $avp(redirect_server);
    $uac_req(furi) = "sip:EXTERNAL_ADDR";
    $uac_req(turi) = $avp(redirect_server);
    $uac_req(callid) = $avp(generated_call_id);
    $uac_req(evroute) = 1;
    $uac_req(evparam) = $avp(generated_call_id);
    xlog("[CHECK_DESTINATION] Cheking $avp(redirect_server)...\n");

    $sht(tsuspenddata=>$avp(generated_call_id))="index=" + $T(id_index) + ";label=" + $T(id_label);
    if (!uac_req_send()) {
        xlog("[$TF][CHECK_DESTINATION] Cannot send to $avp(redirect_server), resuming transaction\n");
        t_continue("$T(id_index)", "$T(id_label)", "SEND_CHECK_FAILED");
    }
    exit;
}

# Wrapper for redirecting requests
route[PROXY_FURTHER] {

    $sht(usertoserver=>$fU) = $avp(redirect_server);

    xlog("[$TF][REDIRECT] Forwarding $rm to $avp(redirect_server)...\n");

    append_hf("X-Orig: $su\n", "Call-ID");

    $du = $avp(redirect_server);

    if (!t_relay()) {
        send_reply("500", "Cannot relay to $avp(redirect_server)");
    }
}


# Wrapper for relaying requests
route[RELAY] {

    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# Per SIP request initial checks
route[INITIAL_CHECK] {

    # First - check SIP message is valid.
    if(!sanity_check("17895", "7")) {
        xlog("L_ALERT", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # flood detection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        # Reply to sip scanners helps according to Daniel-Konstantin Merida
        send_reply("200", "OK");
        xlog("L_INFO","friendly-scanner blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        #sl_send_reply("483","Too Many Hops");
        xlog("L_INFO","maxHop blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        exit;
    }
    if (is_method("ACK") ) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    send_reply("404","Not here");
    exit;
}


# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

route[OPTIONS] {

    if (!is_method("OPTIONS")) {
        return;
    }

    if(uri==myself && $rU==$null) {
        send_reply("200","Keepalive");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
}

route[GET_SERVERS] {
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/0001'
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/700000480001'
    # curl -H "Accept: application/json" -H "Content-Type: application/x-www-form-urlencoded" 'https://relay-api.voipbusiness.com/v1/sip-server/700000460002'

    if ($sht(usertoserver=>$fU) != $null) {
        $avp(redirect_server) = $sht(usertoserver=>$fU);
        xlog("[$TF][GET_SERVERS] Got answer from cache $avp(redirect_server)\n");
        route(REDIRECT);
    }

    $var(http_request_url) = "API_SERVER_ADDRESS/" + $fU;


    $var(http_request_result) = http_client_query("$var(http_request_url)", 
                                                "", 
                                                "Accept: application/json", 
                                                "$avp(http_reply_body)");

    if ($var(http_request_result) != 200) {
        $avp(redirect_server) = "DEFAULT_SERVER";
        route(REDIRECT);
    }

    jansson_array_size("", "$avp(http_reply_body)", "$avp(http_reply_size)");

    xlog("[$TF][GET_SERVERS] Size: $avp(http_reply_size) -> $avp(http_reply_body)\n");

    $avp(current_reply_index) = 0;

    route(MANAGE_HTTP_ANSWER);
}

route[MANAGE_HTTP_ANSWER] {
    if ($avp(http_reply_size) > $avp(current_reply_index)) {

        jansson_get("[$avp(current_reply_index)].sip_server", "$avp(http_reply_body)", "$var(current_sip_server)");
        jansson_get("[$avp(current_reply_index)].port", "$avp(http_reply_body)", "$var(current_sip_port)");
        $avp(redirect_server) = "sip:" + $var(current_sip_server) + ":" + $var(current_sip_port);

        xlog("[$TF][MANAGE_HTTP_ANSWER] About to check $avp(redirect_server)\n");

        $avp(current_reply_index) = $avp(current_reply_index) + 1;

        route(CHECK_DESTINATION);

    } else {
        
        $avp(redirect_server) = "DEFAULT_SERVER";
        xlog("[$TF][MANAGE_HTTP_ANSWER] All servers seems failed, using default one...$avp(redirect_server)\n");

        route(REDIRECT);
    }
}

route[SEND_CHECK_FAILED] {

    xlog("[$TF][SEND_CHECK_FAILED] Check failed, trying next one..\n");

    $sht(tsuspenddata=>$avp(generated_call_id)) = $null;

    route(MANAGE_HTTP_ANSWER);
}


# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }

    route(RTPENGINE);

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        set_contact_alias();
    }

    route(RTPENGINE);
#!endif
    return;
}

route[RTPENGINE] {
#!ifdef WITH_RTPENGINE

    if(!has_body("application/sdp")) {
        return;
    }

    if(isflagset(FLT_FROMINTERNAL)) {
        # Call to external
        rtpengine_manage("direction=internal direction=external no-redis-update replace-origin replace-session-connection ICE=remove");
        return;
    }

    # Call to internal
    rtpengine_manage("direction=external direction=internal no-redis-update replace-origin replace-session-connection ICE=remove");


#!endif
    return;
}

event_route[uac:reply] {

    $var(t_data) = $null;

    xlog("[$TF][UAC_REPLY] Received reply code is: $uac_req(evcode)/$uac_req(evparam)\n");

    $var(t_data) = $sht(tsuspenddata=>$uac_req(evparam));

    if ($var(t_data) == $null || $var(t_data) == "") {
        xlog("[$TF][UAC_REPLY] Data expired?\n");
        drop;
    }

    $var(t_index) = $(var(t_data){param.value,index}{s.int});
    $var(t_label) = $(var(t_data){param.value,label}{s.int});

    if ($uac_req(evcode) != 408) {
        t_continue("$var(t_index)", "$var(t_label)", "REDIRECT");
    } else {
        t_continue("$var(t_index)", "$var(t_label)", "SEND_CHECK_FAILED");
    }
}

failure_route[CHECK_FAILED] {

    route(SEND_CHECK_FAILED);
}


# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

#!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
}