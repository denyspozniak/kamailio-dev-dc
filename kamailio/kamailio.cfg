#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.2 - default configuration script
#     - web: https://www.kamailio.org
#     - git: https://github.com/kamailio/kamailio
#
# Direct your questions about this file to: <sr-users@lists.kamailio.org>
#
# Refer to the Core CookBook at https://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Note: the comments can be:
#     - lines starting with #, but not the pre-processor directives,
#       which start with #!, like #!define, #!ifdef, #!endif, #!else, #!trydef,
#       #!subst, #!substdef, ...
#     - lines starting with //
#     - blocks enclosed in between /* */
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     - define WITH_DEBUG
#
# *** To enable mysql:
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database

# define WITH_DEBUG

#!define WITH_MYSQL
#!define WITH_MULTIDOMAIN
#!define WITH_USRLOCDB

# Initial checks part
#!define WITH_INITIAL_ANTIFLOOD
#!define WITH_INITIAL_UA
#!define WITH_INITIAL_MAXHOP
#!define WITH_INITIAL_RURI
#!define WITH_INITIAL_FROM

# Permissions part
#!define WITH_PERMISSIONS_IP

# Roting check part
#!define WITH_ROUTING_USERDOMAINSUBNET
#!define WITH_ROUTING_REGEXDOMAINSUBNET
#!define WITH_ROUTING_DOMAINS

# NAT part
#!define WITH_NAT
#!define WITH_NATSIPPING
#!define WITH_RTPENGINE

#!define WITH_DISPATCHER

#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:kamailiorw@db/kamailio"
#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#       FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define FLT_FROMINTERNAL 8
#!define FLT_TRUSTED 9

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{[$TF]} "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
 
# First provide internal interfaces to correct dispatcher pings

listen=udp:INTERNAL_IF_ADDR
listen=tcp:INTERNAL_IF_ADDR

listen=udp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR
listen=tcp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR

mhomed=1

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

#!ifdef WITH_TLS
enable_tls=yes

/* upper limit for TLS connections */
tls_max_connections=2048
#!endif

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "phonenum.so"
loadmodule "permissions.so"
loadmodule "path.so"
loadmodule "htable.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!endif


#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!endif
#!endif

#!ifdef WITH_DISPATCHER
loadmodule "dispatcher.so"
#!endif

#!ifdef WITH_ROUTING_USERDOMAINSUBNET
loadmodule "sqlops.so"
#!endif

#!ifdef WITH_ROUTING_REGEXDOMAINSUBNET
loadmodule "group.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_INITIAL_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 3000)
# default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "reparse_on_dns_failover", 0)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU */
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- permissions params -----
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
# load only address and trusted tables
modparam("permissions", "load_backends", 3)

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
/* register callback to match myself condition with domains list */
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
#!ifdef WITH_RTPPROXY
# ----- rtpproxy params -----
modparam("rtpengine", "rtpengine_sock", "udp:localhost:2223")
#!endif

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 10)
#!ifdef WITH_NATSIPPING_ALL
modparam("nathelper", "ping_nated_only", 0)
#!else
modparam("nathelper", "ping_nated_only", 1)
#!endif
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_INITIAL_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

#!ifdef WITH_DISPATCHER
# ----- dispatcher params -----
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_from", "sip:proxy@kamailio")
modparam("dispatcher", "ds_probing_threshold", 2)
modparam("dispatcher", "ds_inactive_threshold", 1)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=404;class=3")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "xavp_dst", "_dsdst_")
modparam("htable", "htable", "callidtodispatcher=>size=8;autoexpire=3600;")
#!endif

#!ifdef WITH_ROUTING_USERDOMAINSUBNET
modparam("sqlops", "sqlcon", SQLOPS_DBURL)
modparam("htable", "htable", "userdomaingroup=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_ROUTING_REGEXDOMAINSUBNET
modparam("group", "db_url", DBURL)
modparam("group", "re_table", "re_grp")
modparam("group", "multiple_gid", 0)
#!endif

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

        route(CHECK_DIAL_OUT);

        # NAT detection. Moved here to route initial answers correctly
        route(NATDETECT);

        # per request initial checks
        route(INITIAL_CHECK);

        route(PERMISSIONS);

        route(OPTIONS);

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }

        # handle retransmissions
        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);

        # record routing for dialog forming requests (in case they are routed)
        # - remove preloaded route headers
        remove_hf("Route");
        if (is_method("INVITE|SUBSCRIBE")) {
            record_route();
        }

        # account only INVITEs
        if (is_method("INVITE")) {
            setflag(FLT_ACC); # do accounting
        }

        # Select dispatcher_id
        route(SELECT_DISPATCHER_ID);

        # handle presence related requests
        route(PRESENCE);

        # handle registrations
        route(REGISTRAR);

        if ($rU==$null) {
            # request with no Username in RURI
            sl_send_reply("484","Address Incomplete");
            exit;
        }

        route(DIAL_OUT);

        route(DIAL_IN);
}

# Wrapper for relaying requests
route[RELAY] {

    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

route[CHECK_DIAL_OUT] {
#!ifdef WITH_DISPATCHER
    if (ds_is_from_list("-1", "3")) {
        setflag(FLT_FROMINTERNAL);
        return;
    }
#!endif
    return;
}

# Per SIP request initial checks
route[INITIAL_CHECK] {

    # First - check SIP message is valid.
    if(!sanity_check("17895", "7")) {
        xlog("L_ALERT", "Malformed SIP message from $si:$sp  UDP fragmentation possible\n");
        exit;
    }

    # No need to check floods and bans from internal systems
    if (isflagset(FLT_FROMINTERNAL) || isflagset(FLT_TRUSTED)) {
        return;
    }
#!ifdef WITH_INITIAL_ANTIFLOOD
    # flood detection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif
#!ifdef WITH_INITIAL_UA
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        # Reply to sip scanners helps according to Daniel-Konstantin Merida
        send_reply("200", "OK");
        xlog("L_INFO","friendly-scanner blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
#!endif
#!ifdef WITH_INITIAL_MAXHOP
    if (!mf_process_maxfwd_header("10")) {
        #sl_send_reply("483","Too Many Hops");
        xlog("L_INFO","maxHop blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
#!endif
#!ifdef WITH_INITIAL_RURI
    if (is_method("INVITE") && phonenum_match("+$rU", "dialed_num")) {
        if ($phn(dialed_num=>valid) != 1) {
            send_reply("400", "Invalid e.164 format");
            xlog("L_ALERT","ALERT: RU: $rU is not e.164 number $phn(dialed_num=>error)\n");
            exit;
        }
        if ($phn(dialed_num=>normalized) != $rU) {
            send_reply("400", "Invalid e.164 format");
            xlog("L_ALERT","ALERT: RU: $rU is not e.164 formatted $phn(dialed_num=>normalized)\n");
            exit;
        }
    } else {
        xlog("L_ALERT","ALERT: libphonenumber call failed, but continue...\n");
    }
#!endif
#!ifdef WITH_INITIAL_FROM
    if (phonenum_match("+$fU", "src_num")) {
        if ($phn(src_num=>valid) != 1) {
            send_reply("400", "Invalid e.164 format");
            xlog("L_ALERT","ALERT: FU: $fU is not e.164 number $phn(src_num=>error)\n");
            exit;
        }
    } else {
        xlog("L_ALERT","ALERT: libphonenumber call failed, but continue...\n");
    }
#!endif
}

route[OPTIONS] {

    if (!is_method("OPTIONS")) {
        return;
    }

    if(uri==myself && $rU==$null) {
        send_reply("200","Keepalive");
        exit;
    }

    if (isflagset(FLT_FROMINTERNAL)) {
        send_reply("200","Keepalive - trusted");
        exit; 
    }
}

route[PERMISSIONS] {

    if (isflagset(FLT_FROMINTERNAL) || isflagset(FLT_TRUSTED)) {
        return;
    }

    $var(permission_not_passed) = $null;

#!ifdef WITH_PERMISSIONS_IP
    if (allow_source_address()) { # Same as allow_address("1", "$si", "$sp")
        setflag(FLT_TRUSTED);
        return;
    }

    $var(permission_not_passed) = 1;
#!endif

    if ($var(permission_not_passed)) {
        xlog("$ru/$fu is not allowed from $si:$sp with mask $var(permission_not_passed)\n");
        send_reply("405", "Not Allowed");
        exit;
    }

    setflag(FLT_TRUSTED);
    
    return;
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        exit;
    }
    if (is_method("ACK") ) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    send_reply("404","Not here");
    exit;
}

route[SELECT_DISPATCHER_ID] {

    if (isflagset(FLT_FROMINTERNAL)) {
        return;
    }

    if ($sht(callidtodispatcher=>$ci) != $null && $sht(callidtodispatcher=>$ci) != "") {
        return;
    }

    # This var will hold dispatcher ID for this request

    $avp(domain_attrs_dispatcher) = $null;

#!ifdef WITH_ROUTING_USERDOMAINSUBNET

    $var(userdomainkey) = $fU + "_" + $fd;

    if ($sht(userdomaingroup=>$var(userdomainkey)) != $null) {
        $avp(domain_attrs_dispatcher) = $sht(userdomaingroup=>$var(userdomainkey));
        xlog("$fu from $si:$sp is matched dispatcher_id $avp(domain_attrs_dispatcher) from cache\n");
        return;
    }
    if (sql_query("groups", "SELECT grp FROM grp WHERE username = '$fU' AND domain = '$fd' LIMIT 1", "rq")) {
        if ($dbr(rq=>rows) == 1) {
            $avp(domain_attrs_dispatcher) = $dbr(rq=>[0,0]);
            $sht(userdomaingroup=>$var(userdomainkey)) = $avp(domain_attrs_dispatcher);
            sql_result_free("rq");
            xlog("$fu from $si:$sp is matched dispatcher_id $avp(domain_attrs_dispatcher) from database and saved in cache\n");
            return;
        }
        sql_result_free("rq");
    }
#!endif

#!ifdef WITH_ROUTING_REGEXDOMAINSUBNET

    $var(userdomainkey) = $fU + "_" + $fd;

    if ($sht(userdomaingroup=>$var(userdomainkey)) != $null) {
        $avp(domain_attrs_dispatcher) = $sht(userdomaingroup=>$var(userdomainkey));
        xlog("$fu from $si:$sp is matched dispatcher_id $avp(domain_attrs_dispatcher) from cache\n");
        return;
    }

    if (get_user_group("From", "$avp(domain_attrs_dispatcher)")) {
        if ($avp(domain_attrs_dispatcher) != $null && $avp(domain_attrs_dispatcher) != "") {
            $sht(userdomaingroup=>$var(userdomainkey)) = $avp(domain_attrs_dispatcher);
            xlog("$fu from $si:$sp is matched dispatcher_id $avp(domain_attrs_dispatcher) from regex and saved in cache\n");
            return;
        }
    }

#!endif

#!ifdef WITH_ROUTING_DOMAINS

    if (!lookup_domain("$rd", "domain_attrs_")) {

        # Try to match against sublevel
        $var(sublevel_lenght) = $(rd{s.select,0,.}{s.len}) + 1;   # subdomain.domain.com -> domain.com
        $var(new_domain) = $(rd{s.strip,$var(sublevel_lenght)});

        if (!lookup_domain("$var(new_domain)", "domain_attrs_")) {
            sl_send_reply("403", "Domain not server here");
            xlog("Request to domain $rd is not allowed from $si:$sp\n");
            exit;
        }
    }
#!endif
    return;
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER") || isflagset(FLT_FROMINTERNAL)) {
        return;
    }

    if(isflagset(FLT_NATS)) {

        setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
        # do SIP NAT pinging
        setbflag(FLB_NATSIPPING);
#!endif
    }
    if ($au != $null) { # Save only with authorized headers. It's actully for pings only
        save("location", "2");
    }

    set_contact_alias();
    add_path_received();

    route(DISPATCHER);

    t_on_failure("REGISTRAR_FAILURE");

    route(RELAY);
}

# User location service
route[LOCATION] {

    route(RELAY);
    exit;
}

# Presence server processing
route[PRESENCE] {

    if(!is_method("PUBLISH|SUBSCRIBE")) {
        return;
    }

    if (!isflagset(FLT_FROMINTERNAL)) {
        route(DISPATCHER);
    } else {
        handle_ruri_alias();
    }

    t_on_failure("PRESENCE_FAILURE");

    route(RELAY);
}


route[DIAL_IN] {
    if (!is_method("INVITE")) {
        return;
    }
    route(AUTH_IN); # Check if call for us

    route(DISPATCHER);

    t_on_failure("DIAL_IN_FAILURE");

    route(RELAY);
}

# IP authorization and user authentication
route[AUTH_IN] {
    # authentication not enabled - do not relay at all to foreign networks
    if(uri!=myself) {
        sl_send_reply("403","Not relaying");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(FLT_NATS);
    }
#!endif
    return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }

    route(RTPENGINE);

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        set_contact_alias();
    }

    route(RTPENGINE);
#!endif
    return;
}


route[RTPENGINE] {
#!ifdef WITH_RTPENGINE

    if(!has_body("application/sdp")) {
        return;
    }

    if(isflagset(FLT_FROMINTERNAL)) {
        # Call to external
        rtpengine_manage("direction=internal direction=external no-redis-update replace-origin replace-session-connection ICE=remove");
        return;
    }

    # Call to internal
    rtpengine_manage("direction=external direction=internal no-redis-update replace-origin replace-session-connection ICE=remove");


#!endif
    return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
#!endif
    return;
}

route[DIAL_OUT] {
    if (!isflagset(FLT_FROMINTERNAL)) {
        return;
    }

    t_on_failure("DIAL_OUT_FAILURE");

    handle_ruri_alias();
    route(RELAY);
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
    # allow XMLRPC from localhost
    if ((method=="POST" || method=="GET")
                && (src_ip==127.0.0.1)) {
        # close connection only for xmlrpclib user agents (there is a bug in
        # xmlrpclib: it waits for EOF before interpreting the response).
        if ($hdr(User-Agent) =~ "xmlrpclib") {
            set_reply_close();
        }
        set_reply_no_connect();
        dispatch_rpc();
        exit;
    }
    send_reply("403", "Forbidden");
    exit;
}
#!endif

route[DISPATCHER] {
#!ifdef WITH_DISPATCHER
    if ($sht(callidtodispatcher=>$ci) != $null && $sht(callidtodispatcher=>$ci) != "") {
        $du = $sht(callidtodispatcher=>$ci);
        return;
    }

    if ($avp(domain_attrs_dispatcher) == $null || $avp(domain_attrs_dispatcher) == "") {
        xlog("Dispatcher not found for domain $rd, trying default\n");
        if (!lookup_domain("DEFAULT_DOMAIN", "domain_attrs_")) {
            send_reply("405", "Not allowed");
        }
    }

    if (!ds_select_dst("$avp(domain_attrs_dispatcher)", "1")) {
        send_reply("404", "Not found");
        drop;
    }

    $sht(callidtodispatcher=>$ci) = $du;
#!endif
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

#!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
}

failure_route[REGISTRAR_FAILURE] {

    if (t_is_canceled()) {
         exit;
    }

    if (t_branch_timeout() && !t_branch_replied()) {
        route(NEXT_DISPATCHER);
    }

    if (route(CHECK_EXIT_CODE)) {
        route(NEXT_DISPATCHER);
    }
}

failure_route[PRESENCE_FAILURE] {

    if (t_is_canceled()) {
         exit;
    }

    if (t_branch_timeout() && !t_branch_replied()) {
        route(NEXT_DISPATCHER);
    }

    if (route(CHECK_EXIT_CODE)) {
        route(NEXT_DISPATCHER);
    }
}


failure_route[DIAL_IN_FAILURE] {
    
    if (t_is_canceled()) {
#!ifdef WITH_RTPENGINE
        rtpengine_delete();
#!endif
         exit;
    }

    if (t_branch_timeout() && !t_branch_replied()) {
        route(NEXT_DISPATCHER);
    }

    if (route(CHECK_EXIT_CODE)) {
        route(NEXT_DISPATCHER);
    }
}

failure_route[DIAL_OUT_FAILURE] {

    if (t_is_canceled()) {
#!ifdef WITH_RTPENGINE
        rtpengine_delete();
#!endif
         exit;
    }
}

route[CHECK_EXIT_CODE] {
    
    # 40x code group
    if ($rs =~ "40[045689]") {
        return 1;
    }

    # 41x code group
    if ($rs =~ "41[0125]") {
        return 1;
    }

    # 42x code group
    if ($rs =~ "420") {
        return 1;
    }

    # 48x code group
    if ($rs =~ "48[0148]") {
        return 1;
    }

    # 50x code group
    if ($rs =~ "50[01234]") {
        return 1;
    }

    return 0;
}

route[NEXT_DISPATCHER] {
    xlog("L_ALERT", "Dispatcher $du on $rm failed, trying next.. ");

    if(!ds_next_dst()) {
        xlog("L_ALERT", "... and failed\n");
        send_reply("500", "No destination available");
        exit;
    }

    $sht(callidtodispatcher=>$ci) = $du;
    xlog("L_ALERT", "... setting $du\n");

    route(RELAY);
}