#!KAMAILIO
####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define FLT_FROMINTERNAL 8

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

listen=udp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR
# listen=tcp:EXTERNAL_IF_ADDR advertise EXTERNAL_ADDR
# HTTP 

listen=tcp:EXTERNAL_IFADDRHTTP

mhomed=0

tcp_connection_lifetime=3605
tcp_max_connections=2048
tcp_accept_no_cl=yes

####### Custom Parameters #########

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "uac.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "usrloc.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
loadmodule "registrar.so"
loadmodule "path.so"
loadmodule "xhttp.so"

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 2000)
modparam("tm", "retr_timer1", 250)
modparam("tm", "retr_timer2", 500)
# default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "fr_inv_timer", 60000)
modparam("tm", "reparse_on_dns_failover", 0)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "tsuspenddata=>size=8;autoexpire=5;")
modparam("htable", "htable", "usertoserver=>size=8;autoexpire=600;updateexpire=0")

modparam("uac","restore_mode","none")

modparam("http_client", "connection_timeout", 1)
modparam("http_client", "keep_connections", 1)

modparam("rtpengine", "rtpengine_sock", "udp:localhost:12221")

modparam("nathelper", "natping_interval", 10)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@sipdomain.org")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")


modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

modparam("usrloc", "db_mode", 0)
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)

modparam("xhttp", "url_match", "^/user/")

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

    xlog("[$TF/$rm/$ci][request_route] Received request\n");

    route(CHECK_DIAL_OUT);

    # NAT detection. Moved here to route initial answers correctly
    route(NATDETECT);

    # per request initial checks
    route(INITIAL_CHECK);

    route(WITHINDLG);

    route(RETRANSMISSIONS);

    route(OPTIONS);

    route(CANCEL);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    route(REGISTRAR);

    if ($rU==$null && !is_method("REGISTER")) {
        # request with no Username in RURI and not REGISTER's
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    route(DIAL_OUT);

    route(GET_SERVERS);
}

route[CHECK_DIAL_OUT] {
    #setflag(FLT_FROMINTERNAL);
    return;
}


route[RETRANSMISSIONS] {
    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
}

route[CANCEL] {
    if (!is_method("CANCEL")) {
        return;
    }

    if (t_check_trans()) {
        route(RELAY);
    }
    exit;
}

route[CHECK_DESTINATION] {

    t_on_failure("CHECK_FAILED");

    if (!t_suspend()) {
        send_reply("500", "Suspend failed");
        exit;
    } else {
        xlog("[$TF/$rm/$ci][CHECK_DESTINATION] Suspending $rm at $T(id_index)/$T(id_label)...\n");
    }

    $avp(generated_call_id) = $(mb{s.md5});

    $uac_req(method) = "OPTIONS";
    $uac_req(ruri) = $avp(redirect_server);
    $uac_req(furi) = "sip:EXTERNAL_ADDR";
    $uac_req(turi) = $avp(redirect_server);
    $uac_req(callid) = $avp(generated_call_id);
    $uac_req(evroute) = 1;
    $uac_req(evparam) = $avp(generated_call_id);
    xlog("[CHECK_DESTINATION] Cheking $avp(redirect_server)...\n");

    $sht(tsuspenddata=>$avp(generated_call_id))="index=" + $T(id_index) + ";label=" + $T(id_label);
    if (!uac_req_send()) {
        xlog("[$TF/$rm/$ci][CHECK_DESTINATION] Cannot send to $avp(redirect_server), resuming transaction\n");
        t_continue("$T(id_index)", "$T(id_label)", "SEND_CHECK_FAILED");
    }
    exit;
}

# Wrapper for redirecting/proxying requests
route[PROXY_FURTHER] {

    $sht(usertoserver=>$fU) = "server=" + $avp(redirect_server) + ";mode=" + $avp(km_op_mode);

    if ($avp(km_op_mode) == 'redirect') {
        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Redirecting $rm to $avp(redirect_server)...\n");
        append_branch("$avp(redirect_server)");
        send_reply("302", "Redirect");
        exit;
    }

    if ($avp(km_op_mode) == 'disabled') {
        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Replying 404 to $rm as it's disabled\n");
        send_reply("404", "User not found");
        exit;
    }

    if ($avp(km_op_mode) == 'sip' || $avp(km_op_mode) == 'rtp') {

        xlog("[$TF/$rm/$ci][PROXY_FURTHER] Relaying $rm to $avp(redirect_server) with $avp(km_op_mode) mode\n");
        append_hf("X-Orig-Source: $su\n", "Call-ID");
        $du = $avp(redirect_server);

        route(RELAY);
    }

    xlog("[$TF/$rm/$ci][PROXY_FURTHER] Replying 603 to $rm as mode $avp(km_op_mode) is not known\n");
    send_reply("603", "Decline");
    exit;
}


# Wrapper for relaying requests
route[RELAY] {

    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (!t_relay()) {
        send_reply("500", "Cannot relay to $du/$ru");
    }
    exit;
}


# Per SIP request initial checks
route[INITIAL_CHECK] {

    # First - check SIP message is valid.
    if(!sanity_check("17895", "7")) {
        xlog("L_ALERT", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # flood detection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        # Reply to sip scanners helps according to Daniel-Konstantin Merida
        send_reply("200", "OK");
        xlog("L_INFO","friendly-scanner blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        #sl_send_reply("483","Too Many Hops");
        xlog("L_INFO","maxHop blocking $rm from $fu (IP:$si:$sp)r\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }

    if (is_method("BYE") && $avp(km_op_mode) == 'rtp') {
        rtpengine_delete();
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        exit;
    }
    if (is_method("ACK") ) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    send_reply("404","Not here");
    exit;
}


# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

route[OPTIONS] {

    if (!is_method("OPTIONS")) {
        return;
    }

    if(uri==myself && $rU==$null) {
        send_reply("200","Keepalive");
        exit;
    }
}

# Caller NAT detection
route[NATDETECT] {
    force_rport();
}

# Presence server processing
route[PRESENCE] {

    if(!is_method("PUBLISH|SUBSCRIBE")) {
        return;
    }

    if (!isflagset(FLT_FROMINTERNAL)) {
        route(GET_SERVERS);
    } else {
        handle_ruri_alias();
    }

    route(RELAY);
}

route[GET_SERVERS] {

    if ($sht(usertoserver=>$fU) != $null) {

        $avp(redirect_server) = $(sht(usertoserver=>$fU){param.value,server});
        $avp(km_op_mode) = $(sht(usertoserver=>$fU){param.value,mode});

        xlog("[$TF/$rm/$ci][GET_SERVERS] Got answer from cache $avp(redirect_server) with $avp(km_op_mode) mode\n");
        route(PROXY_FURTHER);
    }

    $var(http_request_url) = "API_SERVER_ADDRESS/" + $fU;


    $var(http_request_result) = http_client_query("$var(http_request_url)", 
                                                "", 
                                                "Accept: application/json", 
                                                "$avp(http_reply_body)");

    if ($var(http_request_result) != 200) {
        xlog("[$TF/$rm/$ci][GET_SERVERS] http_request_result is not 200 ($var(http_request_result))\n");

        route(USE_DEFAULT_ACTION);
    }

    jansson_array_size("", "$avp(http_reply_body)", "$avp(http_reply_size)");

    xlog("[$TF/$rm/$ci][GET_SERVERS] Size: $avp(http_reply_size) -> $avp(http_reply_body)\n");

    $avp(current_reply_index) = 0;

    route(MANAGE_HTTP_ANSWER);
}

route[MANAGE_HTTP_ANSWER] {
    if ($avp(http_reply_size) > $avp(current_reply_index)) {

        if (!jansson_get("[$avp(current_reply_index)].server.sip_server", "$avp(http_reply_body)", "$var(current_sip_server)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get sip_server from JSON $avp(http_reply_body)\n");
            route(USE_DEFAULT_ACTION);
        }

        if (!jansson_get("[$avp(current_reply_index)].server.port", "$avp(http_reply_body)", "$var(current_sip_port)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get sip_port from JSON $avp(http_reply_body), using 5060\n");
            $var(current_sip_port) = '5060';
        }

        if (!jansson_get("[$avp(current_reply_index)].km_op_mode", "$avp(http_reply_body)", "$avp(km_op_mode)")) {

            xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] Cannot get km_op_mode from JSON $avp(http_reply_body), using DEFAULT_KMOPMODE\n");
            $avp(km_op_mode) = "DEFAULT_KMOPMODE";
        }

        $avp(redirect_server) = "sip:" + $var(current_sip_server) + ":" + $var(current_sip_port);

        xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] About to check $avp(redirect_server)\n");

        $avp(current_reply_index) = $avp(current_reply_index) + 1;

        route(CHECK_DESTINATION);

    } else {

        xlog("[$TF/$rm/$ci][MANAGE_HTTP_ANSWER] All servers seems failed, using default one..\n");

        route(USE_DEFAULT_ACTION);
    }
}

route[USE_DEFAULT_ACTION] {

    xlog("[$TF/$rm/$ci][USE_DEFAULT_ACTION] All servers seems failed, using default one..\n");

    $avp(redirect_server) = "DEFAULT_SERVER";
    $avp(km_op_mode) = "DEFAULT_KMOPMODE";

    route(PROXY_FURTHER);
    exit;
}

route[SEND_CHECK_FAILED] {

    xlog("[$TF/$rm/$ci][SEND_CHECK_FAILED] Check failed, trying next one..\n");

    $sht(tsuspenddata=>$avp(generated_call_id)) = $null;

    route(MANAGE_HTTP_ANSWER);
}


# RTPEngine control and signaling updates for NAT traversal
route[NATMANAGE] {
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }

    route(RTPENGINE);

    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        set_contact_alias();
    }
}

route[RTPENGINE] {

    if(!has_body("application/sdp")) {
        return;
    }

    if ($avp(km_op_mode) == 'rtp') {
        rtpengine_manage("no-redis-update replace-origin replace-session-connection ICE=remove");
    }
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) {
        return;
    }

    if(isflagset(FLT_NATS)) {

        setbflag(FLB_NATB);
        # do SIP NAT pinging
        setbflag(FLB_NATSIPPING);
    }
    if ($au != $null) {         # Save only with authorized headers. It's actully for pings only
        save("location", "2");
    }

    set_contact_alias();
    add_path_received();
}

route[DIAL_OUT] {
    if (!isflagset(FLT_FROMINTERNAL)) {
        return;
    }

    handle_ruri_alias();
    route(RELAY);
}

event_route[uac:reply] {

    $var(t_data) = $null;

    xlog("[$TF/$rm/$ci][UAC_REPLY] Received reply code is: $uac_req(evcode)/$uac_req(evparam)\n");

    $var(t_data) = $sht(tsuspenddata=>$uac_req(evparam));

    if ($var(t_data) == $null || $var(t_data) == "") {
        xlog("[$TF/$rm/$ci][UAC_REPLY] Data expired?\n");
        drop;
    }

    $var(t_index) = $(var(t_data){param.value,index}{s.int});
    $var(t_label) = $(var(t_data){param.value,label}{s.int});

    if ($uac_req(evcode) != 408) {
        t_continue("$var(t_index)", "$var(t_label)", "PROXY_FURTHER");
    } else {
        t_continue("$var(t_index)", "$var(t_label)", "SEND_CHECK_FAILED");
    }
}

event_route[xhttp:request] {

    xlog("[$TF/$rm/$ci][xhttp:request] Request is $hu\n");

    switch ($(hu{s.select,2,/})) {
        case "list":
            $var(user_name) = $(hu{s.select,3,/});
            $var(user_data) = $sht(usertoserver=>$var(user_name));

            $var(redirect_server) = $(var(user_data){param.value,server});
            $var(km_op_mode) = $(var(user_data){param.value,mode});

            xhttp_reply("200", "OK", "application/json", 
                "{\"username\":\"$var(user_name)\",\"server\":\"$var(redirect_server)\",\"km_op_mode\":\"$var(km_op_mode)\"}");
            break;
    
        case "delete":
            $var(user_name) = $(hu{s.select,3,/});
            $var(user_data) = $sht(usertoserver=>$var(user_name));
            $sht(usertoserver=>$var(user_name)) = $null;
            xhttp_reply("200", "OK", "application/json", "{\"200\", \"Deleted\"}");
            break;

        default:
            xhttp_reply("200", "OK", "application/json", "{\"200\", \"OK\"}");
    }
}

failure_route[CHECK_FAILED] {
    xlog("[$TF/$rm/$ci][CHECK_FAILED] for $rm/$ci\n");

    route(SEND_CHECK_FAILED);
}


# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("[$TF/$rm/$ci][MANAGE_BRANCH] for $rm/$ci\n");

    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("[$TF/$rm/$ci][MANAGE_REPLY] for $rm/$ci\n");

    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    xlog("[$TF/$rm/$ci][MANAGE_FAILURE] for $rm/$ci\n");

    if (t_is_canceled()) {
        if ($avp(km_op_mode) == 'rtp') {
            rtpengine_delete();
        }
        exit;
    }
}